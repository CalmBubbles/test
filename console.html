<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/>
        
        <title>Console</title>
        
        <style>
:root
{
    --background : black;
    --color : white;
    --blink-smooth : steps(1);
    --blink-speed : 0.5s;
}

html,
body
{
    background : var(--background);
    color : var(--color);
    font-family : monospace;
    margin : 0;
    height : 100%;
}

#con
{
    display : table;
    overflow : hidden;
    overflow-wrap : break-word;
    width :  calc(100% - 20px);
    height : calc(100% - 24px);
    padding : 12px 10px;
}

#cout,
#cin
{
    display : inline;
    margin : 0;
}

#cin
{
    display : none;
}

#cout *,
#cin *
{
    overflow : hidden;
    display : inline-block;
    vertical-align : bottom;
    white-space : pre-wrap;
}

#input
{
    font-size : 1px;
    opacity : 0;
    outline : 0;
    border : 0;
    padding : 0;
    margin : 0;
    pointer-events : none;
}

#cursor
{
    animation : var(--blink-speed) blink var(--blink-smooth) infinite;
    background : var(--color);
}

@keyframes blink
{
    0% { opacity : 1; }
    50% { opacity : 0; }
    100% { opacity : 1; }
}
        </style>
    </head>
    
    <body>
        <div id="con">
            <span id="cout"></span>
            <span id="cin"></span>
        </div>
        
        <script>

class Program
{
    static #colors = [
        "black",
        "blue",
        "green",
        "aqua",
        "red",
        "purple",
        "yellow",
        "white",
        "gray",
        "lightblue",
        "lightgreen",
        "#82fff3",
        "#ff7f7f",
        "#cbc3e3",
        "#ffffe0",
        "#fdfeff"
    ];
    
    static #Con (input)
    {
        switch (input.shift())
        {
            case "info":
                Console.WriteLine(`Console Info\n\tTitle: ${document.title}\n\tScale: ${100 * window.screen.availWidth / document.documentElement.clientWidth}%\n \n\tURL: ${window.location}\n\tTime since start: ${parseInt(performance.now())}ms\n`);
                break;
            case "title":
                if (input.length !== 0)
                {
                    document.title = input.join(" ");
                    
                    Console.Write("Title changed to: ");
                }
                
                Console.WriteLine(document.title);
                break;
            case "scale":
                Console.WriteLine(`${100 * window.screen.availWidth / document.documentElement.clientWidth}%`);
                break;
            case "url":
                Console.WriteLine(window.location);
                break;
            case "time":
                Console.WriteLine(`${parseInt(performance.now())}ms`);
                break;
            case "color":
                const root = document.documentElement;
                
                root.style.setProperty("--background", this.#colors[parseInt(input[0][0], 16)]);
                
                if (input[0].length === 2) root.style.setProperty("--color", this.#colors[parseInt(input[0][1], 16)]);
                break;
            case "create":
                window.open(window.location, null, "location = 0");
                break;
        }
    }
    
    static #Blink (input)
    {
        const root = document.documentElement;
        
        switch (input.shift())
        {
            case "smooth":
                root.style.setProperty("--blink-smooth", input[0] === "true" ? "ease" : "steps(1)");
                break;
            case "speed":
                root.style.setProperty("--blink-speed", `${input[0]}s`);
                break;
        }
    }
    
    static #Vec2 (input)
    {
        switch (input.shift())
        {
            case "distance":
                Console.WriteLine(Math.sqrt((parseFloat(input[0]) - parseFloat(input[2])) ** 2 + (parseFloat(input[1]) - parseFloat(input[3])) ** 2));
                break;
            case "dir":
                const oneParam = 1 - 2 * (input.length === 2);
                const x = parseFloat(input[2] ?? 0) - parseFloat(input[0]) * oneParam;
                const y = parseFloat(input[3] ?? 0) - parseFloat(input[1]) * oneParam;
                const mag = Math.sqrt(x ** 2 + y ** 2);
                
                Console.WriteLine(`${(x / mag) || 0} ${(y / mag) || 0}`);
                break;
        }
    }
    
    static async Main ()
    {
        Console.Write("Console> ");
        
        const input = (await Console.ReadLine()).split(" ");
        
        switch (input.shift())
        {
            case "clear":
                Console.Clear();
                Console.Sleep(200);
                break;
            case "exit":
                window.close();
                break;
            case "eval":
                Console.WriteLine(eval(input.join(" ")));
                break;
            case "console":
                this.#Con(input);
                break;
            case "blink":
                this.#Blink(input);
                break;
            case "vec2":
                this.#Vec2(input);
                break;
            case "help":
            case "?":
                Help.Invoke(input);
                break;
        }
        
        this.Main();
    }
}

class Help
{
    static #Con (input)
    {
        if (input.length === 0)
        {
            Console.WriteLine("Manages the console's configuration.\n\nSubcommands:\n\tcolor\n\tcreate\n\tinfo\n\tscale\n\ttime\n\turl\n");
            
            return;
        }
        
        switch (input.shift())
        {
            case "info":
                Console.WriteLine("Shows all the console's info.");
                break;
            case "scale":
                Console.WriteLine("Shows the console's scale.");
                break;
            case "url":
                Console.WriteLine("Shows the console's URL.");
                break;
            case "time":
                Console.WriteLine("Tells the time since the program started running in milliseconds.");
                break;
            case "color":
                Console.WriteLine("Changes the console's color.\n\nconsole color {background}\nconsole color {background}{foreground}\n\n\tbackground - background color of entire console.\n\tforeground - foreground color of entire console and text.\n\nPossible colors:\n\t0 = Black     8 = Gray\n\t1 = Blue      9 = Light Blue\n\t2 = Green     A = Light Green\n\t3 = Aqua      B = Light Aqua\n\t4 = Red       C = Light Red\n\t5 = Purple    D = Light Purple\n\t6 = Yellow    E = Light Yellow\n\t7 = White     F = Bright White\n");
                break;
            case "create":
                Console.WriteLine("Creates a new console in another window.");
                break;
        }
    }
    
    static Invoke (input)
    {
        if (input.length === 0)
        {
            Console.WriteLine("Gives info about certain commands.\n\nhelp {command}\n\n\tcommand - command that needs help.\n\n\nGlobal commands:\n\n\t?\n\tclear\n\tconsole\n\texit\n\thelp\n");
            
            return;
        }
        
        switch (input.shift())
        {
            case "?":
            case "help":
                Console.WriteLine("Gives info about certain commands.");
                break;
            case "clear":
                Console.WriteLine("Clears the console.");
                break;
            case "exit":
                Console.WriteLine("Exits the console.");
                break;
            case "console":
                this.#Con(input);
                break;
        }
    }
}

        </script>
        <script>

class Console
{
    static #con = null;
    static #cout = null;
    static #cin = null;
    static #cinCursor = null;
    static #cinInput = null;
    static #canType = false;
    static #cinCharCount = 0;
    static #cinText = "";
    static #cinFinishCall = () => { };
    static #callQueue = [];
    static #callQueueActive = false;
    
    static #CursorElement ()
    {
        const cursor = document.createElement("span");
        
        cursor.id = "cursor";
        
        cursor.append(" ");
        
        return cursor;
    }
    
    static #InputElement ()
    {
        const input = document.createElement("input");
        
        input.setAttribute("type", "text");
        input.setAttribute("autocapitalize", "none");
        input.setAttribute("autocomplete", "off");
        
        input.id = "input";
        
        return input;
    }
    
    static #FocusCin ()
    {
        if (!this.#canType) return;
        
        this.#cinInput.focus();
    }
    
    static #SetCin (state)
    {
        if (state === this.#canType) return;
        
        if (state)
        {
            this.#cinCursor = this.#CursorElement();
            this.#cinInput = this.#InputElement();
            
            this.#cin.append(this.#cinCursor, this.#cinInput);
        }
        else
        {
            this.#cinCursor.remove();
            this.#cinInput.remove();
        }
        
        this.#cin.style.display = state ? "inline" : "none";
        
        this.#canType = state;
    }
    
    static #CallQueueAppend (callback)
    {
        if (this.#callQueue.length === 0) this.#callQueue[0] = callback;
        else this.#callQueue.push(callback);
        
        this.#CallQueueIterate();
    }
    
    static #SendCout (text)
    {
        let currentWord = null;
        
        for (let i = 0; i < text.length; i++)
        {
            const newChar = document.createElement(text[i] === "\n" ? "br" : "span");
            
            if (text[i] !== "\n" ) newChar.append(text[i]);
            
            if (text[i] !== " " && text[i] !== "\n")
            {
                if (currentWord == null) currentWord = document.createElement("span");
                
                currentWord.append(newChar);
            }
            
            if (text[i] === " " || text[i] === "\n" || i === text.length - 1)
            {
                if (currentWord != null)
                {
                    this.#cout.append(currentWord);
                    
                    currentWord = null;
                }
                
                if (text[i] === " " || text[i] === "\n") this.#cout.append(newChar);
            }
        }
    }
    
    static async #CallQueueIterate ()
    {
        if (this.#callQueueActive) return;
        
        this.#callQueueActive = true;
        
        const currentList = this.#callQueue;
        
        for (let i = 0; i < currentList.length; i++) await currentList[i]();
        
        this.#callQueue.shift(currentList.length);
        
        this.#callQueueActive = false;
    }
    
    static Init ()
    {
        this.#con = document.querySelector("#con");
        this.#cout = this.#con.querySelector("#cout");
        this.#cin = this.#con.querySelector("#cin");
        
        document.addEventListener("keydown", event => {
            if (!this.#canType) return;
            
            switch (event.key)
            {
                case "Backspace":
                    if (this.#cinCharCount > 0)
                    {
                        const lastChar = this.#cin.querySelector(`#cin_char_${this.#cinCharCount - 1}`);
                        
                        lastChar.remove();
                        
                        this.#cinCharCount--;
                    }
                    break;
                case "Enter":
                    this.#SetCin(false);
                    
                    this.#cinText = this.#cin.textContent;
                    
                    this.#SendCout(`${this.#cinText}\n`);
                    
                    while (this.#cin.firstChild) this.#cin.removeChild(this.#cin.firstChild);
                    
                    this.#cinCharCount = 0;
                    
                    this.#cinFinishCall();
                    
                    this.#cinFinishCall = () => { };
                    break;
            }
        });
        document.addEventListener("keyup", event => {
            if (!this.#canType) return;
            
            const charContent = this.#cinInput.value;
            
            this.#cinInput.value = "";
            
            event.preventDefault();
            
            for (let i = 0; i < charContent.length; i++)
            {
                const newChar = document.createElement("span");
                newChar.id = `cin_char_${this.#cinCharCount}`;
                
                newChar.append(charContent[i]);
                
                this.#cin.insertBefore(newChar, this.#cinCursor);
                
                this.#cinCharCount++;
            }
		});
        
        this.#con.onclick = () => this.#FocusCin();
        
        Program.Main();
    }
    
    static Write (text)
    {
        this.#CallQueueAppend(() => {
            this.#SetCin(false);
            
            this.#SendCout(text);
        });
    }
    
    static WriteLine (text)
    {
        this.Write(`${text}\n`);
    }
    
    static Clear ()
    {
        this.#CallQueueAppend(() => {
            this.#SetCin(false);
            
            while (this.#cout.firstChild) this.#cout.removeChild(this.#cout.firstChild);
        });
    }
    
    static Sleep (time)
    {
        this.#CallQueueAppend(async () => {
            await new Promise(resolve => setTimeout(resolve, time));
        });
    }
    
    static async ReadLine ()
    {
        let end = () => { };
        
        this.#CallQueueAppend(async () => {
            this.#SetCin(true);
            
            this.#FocusCin();
            
            await new Promise(resolve => this.#cinFinishCall = () => {
                end();
                resolve();
            });
        });
        
        await new Promise(resolve => end = resolve);
        
        return this.#cinText;
    }
}

window.onload = () => { Console.Init(); };

        </script>
    </body>
</html>